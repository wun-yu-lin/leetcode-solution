public class No_88_Merge_Sorted_Array {
    class Solution {
        public void merge(int[] nums1, int m, int[] nums2, int n) {
            int p1 = m - 1;
            int p2 = n - 1;

            int allp = m + n - 1;

            while (p2 >= 0) {
                if (p1 >= 0 && nums1[p1] > nums2[p2]) {
                    nums1[allp--] = nums1[p1--];
                    continue;
                }
                nums1[allp--] = nums2[p2--];
                continue;
            }
        }

    }

//這段程式碼是一個典型的**合併排序陣列**的問題解法，主要用來合併兩個已經排序好的陣列，並將結果放入第一個陣列 `nums1` 中。以下是詳細解析：
//        ### 問題背景
//        1. `nums1` 是一個陣列，包含 `m` 個已排序的數字，還有額外的空間用來容納 `nums2` 的元素。
//        2. `nums2` 是另一個包含 `n` 個已排序數字的陣列。
//        3. 要將 `nums2` 中的數字合併到 `nums1` 中，使得 `nums1` 最終包含所有數字並保持排序。
//
//        ---
//
//        ### 參數與變數解釋
//        - **`nums1`**: 第一個陣列，長度為 `m + n`，包含 `m` 個已排序的元素，後面有空位。
//        - **`nums2`**: 第二個陣列，長度為 `n`，包含 `n` 個已排序的元素。
//        - **`m`**: `nums1` 中有效數字的數量。
//        - **`n`**: `nums2` 中有效數字的數量。
//
//        #### 變數初始化：
//        ```java
//        int p1 = m - 1; // 指向 nums1 中最後一個有效數字的位置
//        int p2 = n - 1; // 指向 nums2 中最後一個數字的位置
//        int allp = m + n - 1; // 指向 nums1 的最後一個位置
//        ```
//        這些變數用來反向遍歷陣列，從兩個陣列的尾部開始比較，確保數字可以就地合併進 `nums1` 的最後位置。
//
//        ---
//
//        ### 邏輯核心
//        #### While 迴圈：
//        ```java
//        while (p2 >= 0) {
//        ```
//        - 只要 `nums2` 中還有元素未處理，就持續執行。
//        - 為什麼不檢查 `p1`？因為當 `nums1` 的有效數字用完時，只需把 `nums2` 的數字直接放入即可。
//
//        ---
//
//        #### If 條件：
//        ```java
//        if (p1 >= 0 && nums1[p1] > nums2[p2]) {
//        nums1[allp--] = nums1[p1--];
//        continue;
//        }
//        ```
//        - 當 `p1 >= 0`（`nums1` 仍有未處理的數字），並且 `nums1[p1] > nums2[p2]` 時：
//        1. 將 `nums1[p1]` 放入 `nums1[allp]`。
//        2. 更新指標：`p1--`（指向 `nums1` 的上一個數字），`allp--`（指向下一個空位）。
//        - 為什麼這樣做？
//        - 因為合併需要保持排序，較大的數字應該放在後面。
//
//        ---
//
//        #### Else：
//        ```java
//        nums1[allp--] = nums2[p2--];
//        ```
//        - 當 `nums1[p1] <= nums2[p2]` 或 `p1 < 0`（`nums1` 已處理完）時：
//        1. 將 `nums2[p2]` 放入 `nums1[allp]`。
//        2. 更新指標：`p2--`，`allp--`。
//
//        ---
//
//        ### 關鍵邏輯
//        1. **從尾部往前合併**：
//        - 使用指標 `allp`，從後向前填充陣列，避免覆蓋未處理的數字。
//        2. **比較兩個陣列的數字大小**：
//        - 總是選擇較大的數字填入 `nums1`，確保排序正確。
//        3. **處理剩餘元素**：
//        - 如果 `nums2` 中還有數字，直接填入 `nums1`。
//
//        ---
//
//        ### 範例執行
//        假設：
//        ```java
//        nums1 = [1, 2, 3, 0, 0, 0], m = 3
//        nums2 = [2, 5, 6], n = 3
//        ```
//
//        步驟：
//        1. 初始指標：
//        ```
//        p1 = 2 (指向 3), p2 = 2 (指向 6), allp = 5
//        ```
//        2. 比較 `nums1[p1]` 和 `nums2[p2]`：
//        - `3 < 6`，將 `6` 放到 `nums1[5]`：
//        ```
//        nums1 = [1, 2, 3, 0, 0, 6], p2--, allp--
//        ```
//        3. 繼續比較：
//        - `3 < 5`，將 `5` 放到 `nums1[4]`：
//        ```
//        nums1 = [1, 2, 3, 0, 5, 6], p2--, allp--
//        ```
//        4. 繼續比較：
//        - `3 > 2`，將 `3` 放到 `nums1[3]`：
//        ```
//        nums1 = [1, 2, 3, 3, 5, 6], p1--, allp--
//        ```
//        5. 繼續比較：
//        - `2 == 2`，將 `2` 放到 `nums1[2]`：
//        ```
//        nums1 = [1, 2, 2, 3, 5, 6], p2--, allp--
//        ```
//        6. 最後剩下 `1` 和 `2`，直接放入 `nums1` 中。
//
//        結果：
//        ```java
//        nums1 = [1, 2, 2, 3, 5, 6]
//        ```
//
//        ---
//
//        ### 時間與空間複雜度
//        - **時間複雜度**：\(O(m + n)\)，因為每個元素最多處理一次。
//        - **空間複雜度**：\(O(1)\)，在 `nums1` 中就地合併，未使用額外空間。
//
//        這段程式碼透過反向填充與就地操作，實現了高效的合併排序。
}

